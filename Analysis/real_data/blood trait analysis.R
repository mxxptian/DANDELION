################################################################################
# Function: filter_trans_by_gwas
#
# Purpose:
#   Perform GWAS-informed filtering of DANDELION mediation results by retaining
#   only trans-regulatory SNPs located within a specified genomic window around
#   GWAS risk loci.
#
# Input file structure and naming convention:
#   Trait names are inferred from file names located in:
#     <ukb_dir>/whole_blood/
#
#   Each file must follow the naming pattern:
#     <trait_name>_<suffix>.Rdata
#
#   where:
#     - <trait_name> uniquely identifies the phenotype and must not contain
#       underscores.
#     - <suffix> is arbitrary and ignored by the pipeline.
#
#   Example:
#     BMI_whole_blood.Rdata
#     LDL_whole_blood.Rdata
#
#   The trait name is extracted as the substring before the first underscore
#   and is used consistently to:
#     (i) locate trans-eQTL mediation results in <trans_dir>/<trait_name>/,
#     (ii) match GWAS phenotypes in the phenotype mapping file,
#     (iii) name output files generated by the pipeline.
#
#   File names are treated as metadata only; the files themselves are not loaded.
#
# Key variables:
#   - file_list: character vector of file names under <ukb_dir>/whole_blood/
#   - info.out: matrix obtained by splitting file_list on underscores
#   - info.out[p, 1]: trait name used throughout the analysis pipeline
#
# Important constraints:
#   - Trait names containing underscores will break trait parsing and are not
#     supported.
#   - Each file must correspond to a single phenotype.
#   - Files must be located under the 'whole_blood' subdirectory.
#
# Genome build and SNP annotation:
#   SNP genomic coordinates are annotated under GRCh37 (hg19).
#   Deprecated or merged rsIDs are resolved using the rsMergeArch database
#   prior to GWAS proximity filtering.
#
# Output:
#   For each trait, filtered mediation results are saved as:
#     <output_dir>/<trait_name>_pair_rsid_gwas.Rdata
#
################################################################################



filter_trans_by_gwas <- function(
    trans_dir,
    ukb_dir,
    gwas_file,
    phenotype_file,
    rsmerge_file,          # rsMergeArch.bcp.gz
    output_dir,
    dist = 1e6             # Â±1Mb GWAS window
) {
  
  library(biomaRt)
  library(rsnps)
  library(dplyr)
  library(data.table)
  
  ##############################################################################
  # Connect to Ensembl SNP database using GRCh37 (hg19)
  ##############################################################################
  ensembl <- useEnsembl(
    biomart = "snp",
    dataset = "hsapiens_snp",
    GRCh = 37
  )
  
  ##############################################################################
  # Load rsMergeArch table for resolving deprecated / merged rsIDs
  ##############################################################################
  rsmerge <- fread(rsmerge_file, header = FALSE, sep = "\t")
  rsmerge <- rsmerge[, 1:2]
  colnames(rsmerge) <- c("merged_rsid", "current_rsid")
  rsmerge$merged_rsid <- as.character(rsmerge$merged_rsid)
  
  ## Helper function: resolve merged rsIDs
  resolve_merged_rsids <- function(rsid_list, rsmerge_table) {
    
    rsid_num <- gsub("rs", "", rsid_list)
    
    res <- data.table(
      input_rsid = rsid_list,
      merged_to  = rsid_num
    )
    
    res <- merge(
      res, rsmerge_table,
      by.x = "merged_to",
      by.y = "merged_rsid",
      all.x = TRUE
    )
    
    ## If rsID was merged, use the current rsID; otherwise keep original
    res[, final_rsid := ifelse(
      is.na(current_rsid),
      paste0("rs", merged_to),
      paste0("rs", current_rsid)
    )]
    
    return(res[, .(input_rsid, final_rsid)])
  }
  
  ##############################################################################
  # Infer trait names from UK Biobank directory
  ##############################################################################
  file_list <- list.files(file.path(ukb_dir, "whole_blood"))
  info.out  <- do.call(rbind, strsplit(file_list, "_"))
  
  ## Load GWAS summary statistics and phenotype mapping
  GWAS  <- read.delim(gwas_file, sep = "\t")
  pheno <- read.csv(phenotype_file)
  
  ##############################################################################
  # Loop over traits
  ##############################################################################
  for (p in seq_len(nrow(info.out))) {
    
    trait <- info.out[p, 1]
    message("Processing trait: ", trait)
    
    ## Load trans-eQTL mediation (DACT) results
    load(file.path(
      trans_dir, trait,
      paste0(trait, "_trans_eQTL_DACT_matp.Rdata")
    ))
    
    ## Extract unique trans-regulatory SNPs
    snp_list <- unique(result.pair$pairs_dact$rsid)
    
    ############################################################################
    # Step 1: Query SNP positions from Ensembl (hg19)
    ############################################################################
    SNPs <- getBM(
      attributes = c("refsnp_id", "chr_name", "chrom_start", "chrom_end"),
      filters    = "snp_filter",
      values     = snp_list,
      mart       = ensembl,
      uniqueRows = TRUE
    )
    
    ## Identify SNPs missing from Ensembl
    missing_rsids <- setdiff(snp_list, SNPs$refsnp_id)
    message("Missing SNPs in Ensembl: ", length(missing_rsids))
    
    ############################################################################
    # Step 2: Resolve deprecated / merged rsIDs using rsMergeArch
    ############################################################################
    if (length(missing_rsids) > 0) {
      
      rsid_map <- resolve_merged_rsids(
        rsid_list    = missing_rsids,
        rsmerge_table = rsmerge
      )
      
      ## Re-query Ensembl using resolved rsIDs
      snp_recovered <- getBM(
        attributes = c("refsnp_id", "chr_name", "chrom_start", "chrom_end"),
        filters    = "snp_filter",
        values     = rsid_map$final_rsid,
        mart       = ensembl,
        uniqueRows = TRUE
      )
      
      SNPs <- rbind(SNPs, snp_recovered)
    }
    
    ############################################################################
    # Step 3: Final SNP QC
    # Retain only SNPs with valid autosomal chromosome annotation
    ############################################################################
    SNPs_all <- SNPs[!is.na(as.numeric(SNPs$chr_name)), ]
    message("Final annotated SNPs: ", nrow(SNPs_all))
    
    ############################################################################
    # Step 4: GWAS proximity filtering
    ############################################################################
    GWAS.sub <- GWAS %>%
      filter(DISEASE.TRAIT %in% pheno$Traits[p]) %>%
      mutate(
        start = CHR_POS - dist,
        end   = CHR_POS + dist
      )
    
    sig_snp <- list()
    
    for (snp in snp_list) {
      
      snp_pos <- SNPs_all[SNPs_all$refsnp_id == snp, ]
      if (nrow(snp_pos) == 0) next
      
      gwas_chr <- GWAS.sub[GWAS.sub$CHR_ID == snp_pos$chr_name, ]
      idx <- which(
        gwas_chr$start <= snp_pos$chrom_start &
          gwas_chr$end   >= snp_pos$chrom_start
      )
      
      if (length(idx) > 0) {
        sig_snp[[length(sig_snp) + 1]] <-
          data.frame(
            rsid     = snp,
            gwas_snp = gwas_chr$SNPS[idx],
            chr_pos  = gwas_chr$CHR_POS[idx]
          )
      }
    }
    
    sig_snp <- bind_rows(sig_snp)
    
    ## Retain only GWAS-proximal trans regulators
    result.pair$pairs_dact <-
      result.pair$pairs_dact %>%
      filter(rsid %in% sig_snp$rsid)
    
    ############################################################################
    # Save GWAS-filtered mediation results
    ############################################################################
    dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
    save(
      result.pair,
      file = file.path(output_dir, paste0(trait, "_pair_rsid_gwas.Rdata"))
    )
  }
}




collapse_trans_locus <- function(
    gwas_dir,
    gene_position_file,
    window = 5e5
) {
  
  library(dplyr)
  
  ## Load reference gene positions (hg37)
  ref.table <- read.delim(gene_position_file, sep = " ")
  ref.table <- ref.table[!duplicated(ref.table$gene_name), ]
  
  ## Identify all traits processed in Stage 1
  traits <- list.files(gwas_dir, pattern = "_pair_rsid_gwas.Rdata")
  
  for (file in traits) {
    
    trait <- sub("_pair_rsid_gwas.Rdata", "", file)
    message("Collapsing loci for trait: ", trait)
    
    ## Load GWAS-filtered trans-eQTL pairs
    load(file.path(gwas_dir, file))
    
    ## Extract unique gene pairs
    gene.pair <- result.pair$pairs_dact %>%
      select(gene1, gene2) %>%
      distinct()
    
    ## Remove Ensembl version suffix if present
    gene.pair$gene1 <- sub("\\..*", "", gene.pair$gene1)
    
    ## Initialize region labels
    gene.pair$region <- gene.pair$gene1
    
    ## Subset reference gene positions
    ref.sub <- ref.table[ref.table$gene_name %in% gene.pair$gene1, ]
    
    ## Collapse nearby genes on the same chromosome
    for (chr in unique(ref.sub$Chromosome)) {
      
      chr.genes <- ref.sub[ref.sub$Chromosome == chr, ]
      chr.genes <- chr.genes[order(chr.genes$start), ]
      
      i <- 1
      while (i <= nrow(chr.genes)) {
        
        ## Define locus window around current gene
        start <- chr.genes$start[i] - window
        end   <- chr.genes$end[i]   + window
        
        ## Identify genes within the locus window
        idx <- which(
          chr.genes$start >= start &
            chr.genes$end   <= end
        )
        
        ## Assign locus label as a comma-separated gene set
        gene.pair$region[
          gene.pair$gene1 %in% chr.genes$gene_name[idx]
        ] <- paste(chr.genes$gene_name[idx], collapse = ",")
        
        ## Move to the next unassigned gene
        i <- max(idx) + 1
      }
    }
    
    ## Save locus-collapsed results
    save(
      gene.pair,
      file = file.path(
        gwas_dir,
        paste0(trait, "_pair_one_locus_gwas.Rdata")
      )
    )
  }
}
